## App优化之卡顿

### 1. 16ms原则

Android 系统会每隔16ms发出VSYNC信号重绘界面。为什么是16ms呢，因为Android设定的刷新频率是60FPS(Frame Per Second)，也就是每秒60帧的频率，约合16ms刷新一次。

造成页面卡顿的原因就是我们无法在16ms内完成下次界面刷新所需要的数据，这样用户就需要再等16ms甚至更长的时间才能见到改变后的界面，这样给用户的感觉就是丢帧了。

### 2. 卡顿原因

#### 2.1 复杂的布局

界面性能取决于UI渲染的性能，UI渲染的整个过程我们可以理解为由CPU和GPU两部分协作完成的，CPU负责UI元素的Measure，Layout，Draw，而GPU简单来说就是负责把Measure，Layout，Draw得到的UI数据绘制到屏幕上，如果我们的UI布局层次太深，可能导致CPU在Measure，Layout，Draw上花去的时间大于16ms，导致卡顿。

这种问题我们可以使用HierarchyViewer工具来检测并定位问题。

#### 2.2 过度绘制

前面复杂的布局中说的是CPU的Measure，Layout，Draw，这里要说的是GPU的绘制，如果GPU存在过度绘制的问题，也会导致卡顿。什么是过度绘制？在理想情况下，屏幕每一帧上的每个像素点应该只会被绘制一次，如果存在多次绘制的情况就是过度绘制了。

##### 2.2.1 检测过度绘制

Android系统的移动设备上一般都会提供有“调试GPU过度绘制”的功能，在开发者模式下就能找到。我们开启这个功能后会发现界面上会出现蓝色，绿色，粉色，红色等区块，这些颜色分别表示的意思如下：

- 蓝色：1次绘制
- 绿色：2次绘制
- 粉色：3次绘制
- 红色：4次及4次以上绘制
- 原色：没有绘制(这个不是太理解，**原色是什么色？？**)

一般来说蓝色肯定是最优的，但是绿色也是可以接受的，如果是粉色或者红色就要考虑是否可以优化了。

##### 2.2.2 过度绘制的原因

前面我们说过所谓过度绘制就是一个像素点绘制了多次，常见的有以下原因导致：

- 绘制了多重背景
- 不可见的View被绘制了(比如View被设置了INVISIBLE)

绘制多重背景应该是最常见的，比如一个LinearLayout设置了白色背景，然后给内部的子View又设置了白色背景，那么加上Window默认的主题背景，这样就绘制了3次，可以想象，当打开”调试GPU过度绘制“功能后，可以看到满屏的粉色或者红色。如何优化？在不影响最后显示效果的情况下，我们可以不要设置LinearLayout或者Window的背景，只留子View的背景，或者LinearLayout和子View不要设置背景，只留Window默认的背景，不管怎样，只绘制一次是最好的，并且恰好实现你想要显示的效果。如果真遇到了那种UI元素比较丰富的界面，再怎么优化都避免不了要过度绘制，那也是没有办法的，所以说，优化只是让我们的应用用起来更流畅，而不是为了优化削减应用的功能或者简化界面的显示效果，有句话说的好：“哪天你的app做到像天猫那样卡的时候，说明你离成功不预远了”。

去掉window的背景方法：

```java
//设置主题
<item name="android:windowBackground">@null</item>

//通过代码
getWindow().setBackgroundDrawable(null);
```

当然了，过度绘制的原因可不止上面所述的两种情况。

#### 2.3 频繁的GC

首先说一下为什么频繁的GC会导致界面卡顿呢？因为我们的**VM在执行GC的时候，所有线程的任何操作都需要暂停，等待GC的完成**，因此频繁的GC会导致界面的卡顿。

导致频繁GC的原因：

- 内存抖动(Memory Churn)，即大量的对象被创建又在短时间内释放；
- 瞬间产生的大量对象会严重占用Young Generation的内存区域，当达到阈值并且剩余空间不足的时候，就会触发GC。一般来说，瞬间产生大量对象是在循环中new出来的或者onDraw()方法中创建对象，因此，我们开发中在这些地方创建对象的时候需要三思而后行。