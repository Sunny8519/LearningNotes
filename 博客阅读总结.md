### 1. [ViewPager 系列之 打造一个通用的 ViewPager](https://juejin.im/post/592df5b12f301e006c749de1)

总结：上面这篇文章中对于ViewPager的通用封装其实只是做到了一部分，并没有做到完全的通用性封装，它只是考虑到了页面基于数据驱动的情况，也如文章所述那样借鉴了RecyclerView的ViewHolder思想。的确，RececlerView其实也是基于数据驱动的，即有多少数据就有多少个Item。但是在RecyclerView中有多种类Item的情况，按照文章所述的那样封装，当ViewPager出现多种类Item时是否还适用呢？还有就是ViewPager在某些应用场景下是不基于数据的，只是单纯的展示几个View，每个View中有各自的逻辑，这种情况又该如何？基于PagerAdapter封装只是简化了ViewPager应用中的一部分，ViewPager还有与Fragment协同使用的场景。

### 2. [Android自定义View之 实现一个多功能的IndicatorView](https://www.jianshu.com/p/7833d8450405)

总结：关键问题在于圆心坐标的确立，这里采用的方式是：第一个圆心的横坐标为半径的大小，其余圆心的横坐标在第一个圆的圆心横坐标基础上+直径+两个圆之间的间距，纵坐标统一为View高度的一半。内部实现ViewPager的OnPageChangeListener，监听ViewPager的Item位置，通过position重新绘制View，并根据不同的position绘制对应的圆的样式，表示被选中。点击圆跳转ViewPager可判断手指触摸时的位置位于第几个圆上，然后切换相应的ViewPager。

### 3. [多层嵌套后的 Fragment 懒加载实现](https://juejin.im/post/5adcb0e36fb9a07aa7673fbc)

总结：
Fragment实现懒加载带来的好处：节省用户流量，提高应用性能。

### 4. [(Android Studio 3.0）Android Profiler内存泄漏检查](https://blog.csdn.net/double2hao/article/details/78784758)

总结：
利用Android Profile进行内存泄漏分析时有两种方式，一种是使用Dump Java heap按钮，一种是使用Record Memory Allocations红色按钮。

Dump Java Heap按钮的使用：这个按钮的作用是显示**此刻**Java堆中的对象及引用情况，比如我们从Activity1跳转到Activity2，然后再回到Activity1，如果想要知道Activity2是否内存泄漏，我们得在做完上面一系列的操作并最终回到了Activity1的页面的时候，点击这个按钮检测此时Java堆中的对象分配情况(建议在点击Dump Java Heap按钮之前先点击force garbage collection按钮先回收一波内存，把能回收的对象回收了，以免这些对象混入我们的查看列表中)，我们可以按照包名来查看我们应用程序下可能发生内存泄漏的对象列表，其他包名下的对象分配情况一般是不需要关心的。这种方式查看内存溢出一般只能定位到某个类，大概是什么导致了内存溢出，具体出现内存溢出的地方不会明确告知。

Record Memory Allocaitions按钮的使用：Activity1跳转Activity2，再回到Activity1，检测Activity2是否内存泄漏，我们需要在进行操作之前就开启这个按钮，然后进行一系列的操作再回到Activity1，再结束记录。同样的，我们按照包名来排序，找到自己的应用程序包名，查看对象列表就可以看到内存泄漏的对象，这个对象列表不会展示其他对象，只会展示内存泄漏的对象，如果没有内存泄漏的对象，我们可能就找不到自己的应用程序包名。我们点开内存泄漏的对象可以定位到发生内存泄漏的代码。个人认为这种方式会更方便一些。

### 5. [源码分析篇 - Android绘制流程（三）requestLayout()与invalidate()流程及Choroegrapher类分析](http://www.cnblogs.com/tiger-wang-ms/p/6592189.html)



### 6. [Android Scroller完全解析，关于Scroller你所需知道的一切](https://blog.csdn.net/guolin_blog/article/details/48719871)



### 7. [Android源码解析——Toast](https://blog.csdn.net/maosidiaoxian/article/details/51327424)

1. Toast如何做到一个接着一个显示的？
2. Toast内部的Handler有什么用处？


### 8. [使用 CPU Profiler 检查 CPU Activity 和函数跟踪](https://developer.android.google.cn/studio/profile/cpu-profiler)



### 9. [ORM对象关系映射之GreenDAO源码解析](https://blog.csdn.net/u010687392/article/details/48465315)

在配置build.gradle中配置GreenDao时可以指定GreenDao自动生成的代码防止的位置，比如：

```java
greendao {
    daoPackage 'com.cnmts.db'
    targetGenDir 'src/main/java'
    schemaVersion 3
}
```

![GreenDao配置存放路径.png](https://upload-images.jianshu.io/upload_images/5231076-4d5715f954f91194.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这篇文章比较老，但是不碍于对GreenDao四个核心类的理解。

四个核心类：DaoMaster,DaoSession,XXXDao,XXXEntity

GreenDao在更新数据库的时候会把原来的数据表全部删掉，然后再重新创建，这就意味着在本地数据库升级的时候，如果不做处理，原来的数据会被删除，造成数据的丢失。**如需保证数据不丢失需要自己封装方法，如何封装呢？？**

**DaoConfig类是用来干嘛的？**它被以Map的形式保存在AbstractDaoMaster抽象类中，key是XXXDao.class。

AbstractDaoSession中也提供了一些CRUD操作，这些操作的背后其实都是调用的是相应Entiry的AbstractDao类。

AbstractDao和DaoConfig类是一一对应的，每个AbstractDao类都有一个DaoConfig类，AbstractDao类中持有DaoConfig对象的引用，而每个DaoConfig类都映射到了数据库中的某个数据表，因此对AbstractDao进行CRUD操作就能直接更改数据库表中的数据，相当于间接对数据库表进行了CRUD操作。 

每个Entity对应的DaoConfig对象是在DaoMaster构造的时候创建的，DaoMaster(实际上是AbstractDaoMaster)中会以XXXDao.class为key存储DaoConfig对象。在DaoSession构建的时候DaoSession对象会持有每个Entity对应的DaoConfig对象以及XXXDao对象并把每个XXXDao对象以XXXDao.class为key存储在AbstractDaoSession类中。

DaoSesstion和XXXDao都提供了CRUD操作。

**GreenDao在查询数据时加入了缓存，相关类为AbstractQueryData，需要研究**

在XXXDao类中会依据Entity的每个属性生成对应的Properties对象，Properties类提供了一系列的条件查询，比如：

````java
    ...     
    /** Creates an "equal ('=')" condition  for this property. */
    public WhereCondition eq(Object value) {
        return new PropertyCondition(this, "=?", value);
    }

    /** Creates an "not equal ('<>')" condition  for this property. */
    public WhereCondition notEq(Object value) {
        return new PropertyCondition(this, "<>?", value);
    }

    /** Creates an "LIKE" condition  for this property. */
    public WhereCondition like(String value) {
        return new PropertyCondition(this, " LIKE ?", value);
    }
    ...
````

以上为该篇博客全部总结。

### 10. [GreenDao学习笔记](https://www.jianshu.com/p/e6c52fb7103d)



### 11. [如何构建Android MVVM应用程序](https://www.jianshu.com/p/2fc41a310f79)

#### 

#### 12. [Kotlin-Android-Extensions：不仅仅是替代findViewById](https://blog.csdn.net/AndrLin/article/details/78055825)

添加插件：

```java
apply plugin: 'kotlin-android-extensions'
```

kotlin-android-extensions是kotlin为Android提供的扩展插件。

Android开发中使用该插件后可以不用再调用findViewById()方法，在代码中我们可以直接调用xml文件中定义的控件id，然后获取到该控件的相关属性。

原理：
通过查看代码反编译后的Java类文件，可以知道该插件在编译后添加了findViewById()获取到的View的缓存，也就是说当我们第一次去获取View的时候会调用findViewById()方法，但是之后都是从缓存中取得，这一部分的工作都是插件帮我们自动生成的。

ViewHolder中要使用Extansions需要实现LayoutContainer接口。

我们可以通过@ContainerOptions注解来修改View的缓存类型：

````java
@ContainerOptions(CacheImplementation.SPARSE_ARRAY)
class TestActivity : AppCompatActivity() {
    ...
}

public enum class CacheImplementation {
    SPARSE_ARRAY,
    HASH_MAP,
    NO_CACHE;

    public val hasCache: Boolean
        get() = this != NO_CACHE

    companion object {
        val DEFAULT = HASH_MAP
    }
}
````

以上为该篇博客全部总结。

