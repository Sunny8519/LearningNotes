[ViewPager 系列之 打造一个通用的 ViewPager](https://juejin.im/post/592df5b12f301e006c749de1)

总结：上面这篇文章中对于ViewPager的通用封装其实只是做到了一部分，并没有做到完全的通用性封装，它只是考虑到了页面基于数据驱动的情况，也如文章所述那样借鉴了RecyclerView的ViewHolder思想。的确，RececlerView其实也是基于数据驱动的，即有多少数据就有多少个Item。但是在RecyclerView中有多种类Item的情况，按照文章所述的那样封装，当ViewPager出现多种类Item时是否还适用呢？还有就是ViewPager在某些应用场景下是不基于数据的，只是单纯的展示几个View，每个View中有各自的逻辑，这种情况又该如何？基于PagerAdapter封装只是简化了ViewPager应用中的一部分，ViewPager还有与Fragment协同使用的场景。

[Android自定义View之 实现一个多功能的IndicatorView](https://www.jianshu.com/p/7833d8450405)

总结：关键问题在于圆心坐标的确立，这里采用的方式是：第一个圆心的横坐标为半径的大小，其余圆心的横坐标在第一个圆的圆心横坐标基础上+直径+两个圆之间的间距，纵坐标统一为View高度的一半。内部实现ViewPager的OnPageChangeListener，监听ViewPager的Item位置，通过position重新绘制View，并根据不同的position绘制对应的圆的样式，表示被选中。点击圆跳转ViewPager可判断手指触摸时的位置位于第几个圆上，然后切换相应的ViewPager。

[多层嵌套后的 Fragment 懒加载实现](https://juejin.im/post/5adcb0e36fb9a07aa7673fbc)

总结：
Fragment实现懒加载带来的好处：节省用户流量，提高应用性能。

[（Android Studio 3.0）Android Profiler内存泄漏检查](https://blog.csdn.net/double2hao/article/details/78784758)

总结：
利用Android Profile进行内存泄漏分析时有两种方式，一种是使用Dump Java heap按钮，一种是使用Record Memory Allocations红色按钮。

Dump Java Heap按钮的使用：这个按钮的作用是显示**此刻**Java堆中的对象及引用情况，比如我们从Activity1跳转到Activity2，然后再回到Activity1，如果想要知道Activity2是否内存泄漏，我们得在做完上面一系列的操作并最终回到了Activity1的页面的时候，点击这个按钮检测此时Java堆中的对象分配情况(建议在点击Dump Java Heap按钮之前先点击force garbage collection按钮先回收一波内存，把能回收的对象回收了，以免这些对象混入我们的查看列表中)，我们可以按照包名来查看我们应用程序下可能发生内存泄漏的对象列表，其他包名下的对象分配情况一般是不需要关心的。这种方式查看内存溢出一般只能定位到某个类，大概是什么导致了内存溢出，具体出现内存溢出的地方不会明确告知。

Record Memory Allocaitions按钮的使用：Activity1跳转Activity2，再回到Activity1，检测Activity2是否内存泄漏，我们需要在进行操作之前就开启这个按钮，然后进行一系列的操作再回到Activity1，再结束记录。同样的，我们按照包名来排序，找到自己的应用程序包名，查看对象列表就可以看到内存泄漏的对象，这个对象列表不会展示其他对象，只会展示内存泄漏的对象，如果没有内存泄漏的对象，我们可能就找不到自己的应用程序包名。我们点开内存泄漏的对象可以定位到发生内存泄漏的代码。个人认为这种方式会更方便一些。

[源码分析篇 - Android绘制流程（三）requestLayout()与invalidate()流程及Choroegrapher类分析](http://www.cnblogs.com/tiger-wang-ms/p/6592189.html)

总结：



[Android Scroller完全解析，关于Scroller你所需知道的一切](https://blog.csdn.net/guolin_blog/article/details/48719871)

