## Java垃圾回收机制

### 1. 垃圾回收机制的意义

它解决了例如C++中的那种令人头疼的内存管理问题，有了垃圾回收机制后，Java中的对象不再有“作用域”概念，只有对象的引用才有“作用域”。垃圾回收机制可以有效的防止内存泄漏，有效的使用空闲的内存。我们有时称内存泄漏位“对象游离”。

### 2. 什么是GC？

GC是Garbage Collection(垃圾回收)的缩写，也可以翻译成Garbage Collector(垃圾回收器)。

垃圾回收器：具体垃圾收集算法的实现；

垃圾回收器的三大职责：

- 分配内存；
- 确保任何被引用的对象保留在内存中；
- 回收不能通过引用关系找到的对象内存。

### 3. 判断对象是否可用算法

#### 3.1 引用计数法(Reference Counting Collector)

引用计数法是早期的一种垃圾收集策略，这种垃圾收集算法，要求堆中的每个对象实例都要有一个引用计数，当一个对象被创建后，每被一个变量引用，实例的引用计数加1，每减少一个变量引用(比如引用超出了生命周期，可以说是作用域吧，或者引用变量被设置了一个新值)，实例的引用计数就减1。当一个实例对象的引用计数为0时，就认为这个对象可以被当做垃圾收集的。当一个对象被收集后，它所引用的任何对象的实例引用计数都会减1。

引用计数法的优点：引用计数收集器可以快速的运行，这对程序需要不被长时间打断的实时环境比较有利。

引用计数法的缺点：无法检测出循环引用，比如下面这样：

```java
public class Main{
    public static void main(String[] args){
        Object1 object1 = new Object1();
        Object1 object2 = new Object1();
        
        object1.object = object2;
        object2.object = object1;
        
        object1 = null;//手动置为null
        object2 = null;
    }
}
```

这里给object1和object2都置为了null，因此object1和object2所引用的实例是不可能再被访问了，但是因为这两个实例相互引用，因此，他们的引用计数器的值不为0，所以，垃圾收集器永远不会回收他们，这就造成了内存泄漏。

#### 3.2 可达性分析法

在可达性分析法中我们可以把所有的引用关系看做一张图(图论中的图)，从一个节点GC Root开始，寻找对应的引用节点，找到这个引用节点后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕后，剩余的节点则被认为是没有被引用的节点。

![GC_Root.png](https://upload-images.jianshu.io/upload_images/5231076-bd65d5866fad0a4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

从上面这张图中我们可以看到objE，objF，objG是没有到GC Root的引用链的，也就是GC Root不可达，所以，他们会被当做垃圾处理，占用的内存空间会被系统回收。

对于可达性分析算法而言，不可达的对象并非是“非死不可”的，若要宣判一个对象的死亡，至少需要经历两次标记阶段。

- 如果一个对象在经过可达性分析后，发现没有到GC Root的引用链，则这个对象会被第一次标记，然后经过一次筛选，筛选的条件就是是否有必要执行该对象的finalize()方法，如果对象没有覆写finalize()方法或者finalize()方法已经被虚拟机执行过了，则视为不必要执行finalize()方法，那么该对象将会被回收。反之，如果对象覆写了finalize()方法并且finalize()方法没有被虚拟机执行过，那么，这个对象会被放置在一个叫F-Queue的队列中，之后的一系列操作由虚拟机自动建立的、优先级低的Finalizer线程执行。
- F-Queue中的对象会进行第二次标记，如果对象在finalize()方法中拯救了自己，即关联上了GC Root的引用链，那么在第二次标记的时候会将对象从“即将回收”的集合中移除，如果此时对象还是没有拯救自己，那么它就会被回收。在finalize()方法中只能拯救自己一次，第二次就要被回收了。

如下代码展示了一个对象在finalize()方法中如何自救的：

```java
package com.demo;

/*
 * 此代码演示了两点：
 * 1.对象可以再被GC时自我拯救
 * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次
 * */
public class FinalizeEscapeGC {
    
    public String name;
    public static FinalizeEscapeGC SAVE_HOOK = null;

    public FinalizeEscapeGC(String name) {
        this.name = name;
    }

    public void isAlive() {
        System.out.println("yes, i am still alive :)");
    }
    
    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("finalize method executed!");
        System.out.println(this);
        FinalizeEscapeGC.SAVE_HOOK = this;
    }

    @Override
    public String toString() {
        return name;
    }

    public static void main(String[] args) throws InterruptedException {
        SAVE_HOOK = new FinalizeEscapeGC("leesf");
        System.out.println(SAVE_HOOK);
        // 对象第一次拯救自己
        SAVE_HOOK = null;
        System.out.println(SAVE_HOOK);
        System.gc();
        // 因为finalize方法优先级很低，所以暂停0.5秒以等待它
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("no, i am dead : (");
        }

        // 下面这段代码与上面的完全相同,但是这一次自救却失败了
        // 一个对象的finalize方法只会被调用一次
        SAVE_HOOK = null;
        System.gc();
        // 因为finalize方法优先级很低，所以暂停0.5秒以等待它
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("no, i am dead : (");
        }
    }
}

运行结果：
leesf
null
finalize method executed!
leesf
yes, i am still alive :)
no, i am dead : (
```

从上面的运行结果可以知道，该对象只是拯救了自己一次，第二次没有拯救成功，因为一个对象的finalize()方法只能被虚拟机执行一次。

### 4. 垃圾回收算法

JVM规范中没有规定JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法是需要做两件基本事情的：

- 发现无用信息的对象(也就是没用的对象)
- 回收被无用对象占用的内存空间，使该空间可以被程序再次使用

#### 4.1 标记-清除(Mark-Sweep)算法

这也是一个非常基础的算法，标记-清除算法就如同他的名字一样，分为“标记”和“清除”两个阶段：先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。

缺点：
1.从效率角度来说，标记和清除的效率不是很高；
2.从空间的角度来说，标记清除后可能会产生大量不连续的内存碎片，内存碎片太多可能会导致程序运行过程需要分配大对象时，无法找到足够的连续内存而不得不提前触发GC。

#### 4.2 复制(Copying)算法

复制算法将我们程序中可用的内存分为两块，每次只用其中的一块，当这一块用完了，就将这一块还存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次性清理掉，这样每次都是对整个半区进行内存的回收，因此就不会存在内存碎片的问题了。

缺点：
内存缩小为了原来的一半，空间使用率不高。

现在的商用虚拟机都是采用这种方式来回收新生代内存，不过研究表明1:1的比例非常的不科学，因此新生代内存被划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。每次回收时，将Eden和Survivor中还存活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。

#### 4.3 标记-整理(Mark-Compact)算法

复制算法在对象存活率高的场景下需要进行大量的复制操作，效率低。标记-整理算法有点类似于标记-清理算法，但是第二阶段不是直接清除，而是先把存活的对象移向一端，再清理掉边界以外的内存。

#### 4.4 分代收集算法

现代商用虚拟机基本采用分代收集算法来进行垃圾回收，这种算法没有什么特别的，无非就是上面几种算法的结合，根据对象的生命周期的不同将内存划分为几块，然后根据各块的特点采用适当的算法。大批对象死去、少量对象存活(新生代)，采用复制算法，复制成本低；对象存活率高，没有额外空间进行分配担保的(老年代)，采用标记-清理算法或者标记-整理算法。

### 5. 四种引用

在JDK1.2之前，Java中的对象只有两种状态，一是被引用，二是不被引用。但是可能会存在这样的一种情景：当内存空间足够时，对象保存在内存中，当内存空间在进行垃圾收集后仍然非常紧张，则可以回收这些对象的内存空间以作他用。因此，在JDK1.2之后，Java扩充了引用的概念，将引用分为强引用、软引用、弱引用、虚引用四种引用类型。

#### 5.1 强引用

类似于`Object obj = new Object();`这种引用都是强引用，只要强引用还在，垃圾收集器就不能把该对象回收。

#### 5.2 软引用

软引用可以用来描述对象还有用但是非必需的，软引用的对象在内存即将发生内存溢出的时候会被垃圾收集器回收，以便释放一定的内存空间保证不会发生内存溢出，但是如果软引用的对象在被回收了之后，内存空间还是不够的话，就会抛出内存溢出异常。Java中的类SoftReference表示软引用。

#### 5.3 弱引用

弱引用可以用来描述非必需的对象，被弱引用关联的对象只能生存到下一次GC之前，在GC之后，都会被回收，当然，前提是这个对象只有弱引用，如果，一个对象既有软引用，又有强引用，那么GC之后，这个对象也不会被回收。Java中的类WeakReference表示弱引用。

#### 5.4 虚引用

被虚引用关联的对象在被GC时会收到系统的通知，它是最弱的一种引用，只要进行了一次GC，它所关联的对象就会被回收。Java中的类PhantomReference表示虚引用。

### 6. 方法区的垃圾回收

方法区的垃圾回收主要回收两部分内容：1.废弃的常量；2.无用的类。那么如何判断哪些是废弃的常量，哪些是无用的类呢？

判断废弃常量：
以字面量回收为例，现在有一个字符串"abc"已经进入了常量池中，但是外界没有任何地方引用到这个字面量，那么在发生垃圾回收时，"abc"就有可能被移除常量池。常量池中的类(接口)、方法、字段的符号引用也类似。

判断无用的类：
1.Java堆中没有该类的任何实例；
2.加载该类的ClassLoader已经被回收；
3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射的方式方位到该类中的方法。
满足上面三个条件的类就可以进行垃圾回收，但是并不代表无用就会被回收，Java虚拟机提供了一些参数供我们配置来决定如何回收。

### 7. 垃圾收集器

垃圾收集器就是前面所述的垃圾回收算法的具体实现了，不同虚拟机提供的垃圾收集器可能会有很大的差别，例如HotSpot虚拟机包含了如下所示的垃圾收集器：

![垃圾收集器.png](https://upload-images.jianshu.io/upload_images/5231076-02a4d737aaad6cc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

上图展示了作用于不同分代的收集器，两个收集器之间有连线，表示它们是可以搭配使用的。

注：没有最好的垃圾收集器，更加没有万能的垃圾收集器，只能选择最合适的垃圾收集器。这也是HotSpot会实现这么多收集器的原因。

#### 7.1 Serial收集器

它是采用复制算法的单线程收集器，单线程一方面意味着它只会使用一个CPU或者一条线程去完成垃圾收集工作，另一方面也意味着它进行垃圾收集时必须暂停其他线程的所有工作，直到它收集结束为止，在用户不可见的情况下要把用户正常工作的线程全部停掉，这对很多应用是难以接受的。不过实际上到目前为止，**Serial收集器依然是虚拟机运行在Client模式下的默认新生代收集器**，因为它简单而高效。用户桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代停顿时间在几十毫秒最多一百毫秒，只要不是频繁发生，这点停顿是完全可以接受的 。

![Serial收集器.png](https://upload-images.jianshu.io/upload_images/5231076-12516fa819a149b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 7.2 ParNew收集器

ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其他行为都和Serial收集器完全一样，它也是使用的复制算法。ParNew算法在Serial算法的基础上虽然没有太多创新的地方，但它却是Server模式下的虚拟机首选的新生代收集器，其中一个和性能无关的原因是除了Serial收集器外，只有它能与CMS收集器配合工作。CMS收集器是一款几乎可以认为具有划时代意义的垃圾收集器，因为它第一次实现了让垃圾收集线程与用户线程基本上同时工作。ParNew收集器在单CPU环境中绝对不会有比Serial收集器更好的效果，但是随着CPU数量的增加，它的性能要远超Serial收集器。

![ParNew收集器.png](https://upload-images.jianshu.io/upload_images/5231076-5bfef342c4edcf0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 7.3 Parallel Scavenge收集器

 Parallel Scavenge收集器也是一个新生代收集器，也是用复制算法的收集器，也是并行的多线程收集器，但是它的特点是它的关注点和其他收集器不同。介绍这个收集器主要还是介绍**吞吐量**的概念。**CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是打到一个可控制的吞吐量**。所谓吞吐量的意思就是CPU用于运行用户代码时间与CPU总消耗时间的比值，即**吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）**，虚拟机总运行100分钟，垃圾收集1分钟，那吞吐量就是99%。另外，**Parallel Scavenge收集器是虚拟机运行在Server模式下的默认垃圾收集器**。

停顿时间短适合需要与用户交互的程序，良好的响应速度能提升用户体验；高吞吐量则可以高效率利用CPU时间，尽快完成运算任务，主要适合在后台运算而不需要太多交互的任务。

虚拟机提供了-XX:MaxGCPauseMillis和-XX:GCTimeRatio两个参数来精确控制最大垃圾收集停顿时间和吞吐量大小。不过不要以为前者越小越好，GC停顿时间的缩短是以牺牲吞吐量和新生代空间换取的。由于与吞吐量关系密切，**Parallel Scavenge收集器也被称为“吞吐量优先收集器”**。Parallel Scavenge收集器有一个-XX:+UseAdaptiveSizePolicy参数，这是一个开关参数，这个参数打开之后，就不需要手动指定新生代大小、Eden区和Survivor参数等细节参数了，虚拟机会根据当前系统的运行情况以及性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。**如果对于垃圾收集器运作原理不太了解，以至于在优化比较困难的时候，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择**。

#### 7.4 Serial Old收集器

Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理”算法，这个收集器的主要意义在于给Client模式下的虚拟机使用。

#### 7.5 Parallel Old收集器

Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器是再JDK1.6之后出现的，“吞吐量优先收集器”终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge收集器+Parallel Old收集器的组合。运行过程如图：

![Parallel_old收集器.png](https://upload-images.jianshu.io/upload_images/5231076-2fa2dfca98e26eea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 7.6 CMS收集器

CMS(Conrrurent Mark Sweep)收集器是以获取最短回收停顿时间为目标的收集器。使用标记-清除算法，垃圾回收过程分为如下四步：

- 初始标记，标记GCRoots能直接关联到的对象，时间很短，这个过程需要暂停所有用户线程；
- 并发标记，进行GCRoots Tracing(可达性分析)过程，时间很长；
- 重新标记，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间较长，这个过程也需要暂停所有用户线程；
- 并发清除，回收内存空间，时间很长。

在这四步中，只有并发标记和并发清除两个过程时间很长，但是它们都可以和用户线程并发执行。运行过程如图所示：

![CMS收集器.png](https://upload-images.jianshu.io/upload_images/5231076-9cb6a2a9e45883b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

说明：1. 对CPU资源非常敏感，可能会导致应用程序变慢，吞吐率下降。2. 无法处理浮动垃圾，因为在并发清理阶段用户线程还在运行，自然就会产生新的垃圾，而在此次收集中无法收集他们，只能留到下次收集，这部分垃圾为浮动垃圾，同时，由于用户线程并发执行，所以需要预留一部分老年代空间提供并发收集时程序运行使用。3. 由于采用的标记 - 清除算法，会产生大量的内存碎片，不利于大对象的分配，可能会提前触发一次Full GC。虚拟机提供了-XX:+UseCMSCompactAtFullCollection参数来进行碎片的合并整理过程，这样会使得停顿时间变长，虚拟机还提供了一个参数配置，-XX:+CMSFullGCsBeforeCompaction，用于设置执行多少次不压缩的Full GC后，接着来一次带压缩的GC。

####  7.7 G1收集器

G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与其他GC收集器相比，G1收集器有以下特点：

(1). 并行和并发。使用多个CPU来缩短Stop The World停顿时间，与用户线程并发执行。

(2). 分代收集。独立管理整个堆，但是能够采用不同的方式去处理新创建对象和已经存活了一段时间、熬过多次GC的旧对象，以获取更好的收集效果。

(3). 空间整合。基于标记 - 整理算法，无内存碎片产生。

(4). 可预测的停顿。能简历可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。

​     在G1之前的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分（可以不连续）Region的集合。

### 8. GC日志

```java
[GC [DefNew: 310K->194K(2368K), 0.0269163 secs] 310K->194K(7680K), 0.0269513 secs] [Times: user=0.00 sys=0.00, real=0.03 secs] 
[GC [DefNew: 2242K->0K(2368K), 0.0018814 secs] 2242K->2241K(7680K), 0.0019172 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (System) [Tenured: 2241K->193K(5312K), 0.0056517 secs] 4289K->193K(7680K), [Perm : 2950K->2950K(21248K)], 0.0057094 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 def new generation   total 2432K, used 43K [0x00000000052a0000, 0x0000000005540000, 0x0000000006ea0000)
  eden space 2176K,   2% used [0x00000000052a0000, 0x00000000052aaeb8, 0x00000000054c0000)
  from space 256K,   0% used [0x00000000054c0000, 0x00000000054c0000, 0x0000000005500000)
  to   space 256K,   0% used [0x0000000005500000, 0x0000000005500000, 0x0000000005540000)
 tenured generation   total 5312K, used 193K [0x0000000006ea0000, 0x00000000073d0000, 0x000000000a6a0000)
   the space 5312K,   3% used [0x0000000006ea0000, 0x0000000006ed0730, 0x0000000006ed0800, 0x00000000073d0000)
 compacting perm gen  total 21248K, used 2982K [0x000000000a6a0000, 0x000000000bb60000, 0x000000000faa0000)
   the space 21248K,  14% used [0x000000000a6a0000, 0x000000000a989980, 0x000000000a989a00, 0x000000000bb60000)
No shared spaces configured.
```

1.日志的开头“GC”、“Full GC”表示这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有Full，则说明本次GC停止了其他所有工作线程(Stop-The-World)。看到Full GC的写法是“Full GC(System)”，这说明是调用System.gc()方法所触发的GC。

2.“GC”中接下来的“[DefNew”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的，例如上面样例所使用的Serial收集器中的新生代名为“Default New Generation”，所以显示的是“[DefNew”。如果是ParNew收集器，新生代名称就会变为“[ParNew”，意为“Parallel New Generation”。如果采用Parallel Scavenge收集器，那它配套的新生代称为“PSYoungGen”，老年代和永久代同理，名称也是由收集器决定的。

3.后面方括号内部的“310K->194K(2368K)”、“2242K->0K(2368K)”，指的是**该区域已使用的容量->GC后该内存区域已使用的容量(该内存区总容量)**。方括号外面的“310K->194K(7680K)”、“2242K->2241K(7680K)”则指的是**GC前Java堆已使用的容量->GC后Java堆已使用的容量(Java堆总容量)**。

4.再往后“0.0269163 secs”表示该内存区域GC所占用的时间，单位是秒。最后的“[Times: user=0.00 sys=0.00 real=0.03 secs]”则更具体了，user表示用户态消耗的CPU时间、内核态消耗的CPU时间、操作从开始到结束经过的墙钟时间。后面两个的区别是，墙钟时间包括各种非运算的等待消耗，比如等待磁盘I/O、等待线程阻塞，而CPU时间不包括这些耗时，但当系统有多CPU或者多核的话，多线程操作会叠加这些CPU时间，所以如果看到user或sys时间超过real时间是完全正常的。

5.“Heap”后面就列举出堆内存目前各个年代的区域的内存情况。

参考文章：

[Java垃圾回收(GC)机制详解](https://www.cnblogs.com/xiaoxi/p/6486852.html)
